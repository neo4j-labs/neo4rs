use bytes::Bytes;
use serde::de::{Deserialize, DeserializeOwned};

#[path = "de.rs"]
pub mod de;
#[path = "ser.rs"]
pub mod ser;

/// Parse and deserialize a packstream value from the given bytes.
pub fn from_bytes<T>(mut bytes: Bytes) -> Result<T, de::Error>
where
    T: DeserializeOwned,
{
    from_bytes_ref(&mut bytes)
}

/// Parse and deserialize a packstream value from the given bytes.
pub fn from_bytes_ref<'de, T>(bytes: &'de mut Bytes) -> Result<T, de::Error>
where
    T: Deserialize<'de>,
{
    let de = de::Deserializer::new(bytes);
    let value = T::deserialize(de)?;

    Ok(value)
}

/// Serialize and packstream encode the given value.
pub fn to_bytes<T>(value: &T) -> Result<Bytes, ser::Error>
where
    T: serde::Serialize,
{
    let mut ser = ser::Serializer::empty();
    value.serialize(&mut ser)?;

    Ok(ser.end())
}

#[cfg(test)]
mod tests {
    use std::{collections::BTreeMap, fmt::Debug};

    use super::*;

    use serde::{Deserialize, Serialize};
    use test_case::test_case;

    #[test]
    fn unit() {
        roundtrip(&[], ());
    }

    #[test]
    fn null() {
        roundtrip(&[0xC0], None::<i32>);
    }

    #[test_case(0xC2, false ; "false value")]
    #[test_case(0xC3, true ; "true value")]
    fn boolean(byte: u8, expected: bool) {
        roundtrip(&[byte], expected);
    }

    #[test_case(&[0x2A], 42; "tiny_int")]
    #[test_case(&[0xF4], -12; "neg_tiny_int")]
    #[test_case(&[0xC8, 0xD6], -42; "int_8")]
    #[test_case(&[0xC9, 0x00, 0xD6], 214; "int_16_u8")]
    #[test_case(&[0xC9, 0x05, 0x39], 1337; "int_16_i16")]
    #[test_case(&[0xC9, 0xFA, 0xC7], -1337; "neg_int_16")]
    #[test_case(&[0xCA, 0x00, 0x00, 0xA4, 0x64], 42084; "int_32_u16")]
    #[test_case(&[0xCA, 0x00, 0x40, 0x1B, 0x79], 4201337; "int_32_i32")]
    #[test_case(&[0xCA, 0xFF, 0xBF, 0xE4, 0x87], -4201337; "neg_int_32")]
    #[test_case(&[0xCB, 0x00, 0x00, 0x00, 0x00, 0xfa, 0x97, 0x05, 0x79], 4204201337; "int_64_u32")]
    #[test_case(&[0xCB, 0x00, 0x00, 0x00, 0x03, 0x1c, 0xf0, 0x6c, 0xc4], 13370420420; "int_64_i64")]
    #[test_case(&[0xCB, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x68, 0xFA, 0x87], -4204201337; "neg_int_64")]
    fn int(input: &'static [u8], expected: i64) {
        roundtrip(input, expected);
    }

    #[test_case(&[0x2A]; "tiny_int")]
    #[test_case(&[0xC8, 0x2A]; "int_8")]
    #[test_case(&[0xC9, 0x00, 0x2A]; "int_16")]
    #[test_case(&[0xCA, 0x00, 0x00, 0x00, 0x2A]; "int_32")]
    #[test_case(&[0xCB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A]; "int_64")]
    fn int_42(input: &'static [u8]) {
        let bytes = Bytes::from_static(input);
        assert_eq!(from_bytes::<i64>(bytes).unwrap(), 42);
    }

    #[test_case(&[0xC1, 0x3F, 0xF3, 0xAE, 0x14, 0x7A, 0xE1, 0x47, 0xAE], 1.23_f64; "float_f64")]
    #[test_case(&[0xC1, 0x3F, 0xF3, 0xAE, 0x14, 0x80, 0x00, 0x00, 0x00], 1.23_f32 as f64; "float_f32")]
    fn float(input: &'static [u8], expected: f64) {
        roundtrip(input, expected)
    }

    #[test_case(&[0xCC, 0x00], Bytes::new(); "empty bytes")]
    #[test_case(&[0xCC, 0x03, 0x01, 0x02, 0x03], Bytes::from_static(&[1, 2, 3]); "123")]
    #[test_case(&[0xCC, 0x0C, 0x68, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x72, 0x75, 0x73, 0x74, 0x21], Bytes::from_static(b"hello, rust!"); "hell")]
    fn bytes(input: &'static [u8], expected: Bytes) {
        roundtrip(input, expected)
    }

    #[test_case(&[0xCC, 0x00], Bytes::new(); "empty bytes")]
    #[test_case(&[0xCC, 0x04, 0x68, 0x65, 0x6C, 0x6C], Bytes::from_static(b"hell"); "hell")]
    #[test_case(&[0xCD, 0x00, 0x04, 0x6F, 0x2C, 0x20, 0x72], Bytes::from_static(b"o, r"); "o, r")]
    #[test_case(&[0xCE, 0x00, 0x00, 0x00, 0x04, 0x75, 0x73, 0x74, 0x21], Bytes::from_static(b"ust!"); "ust!")]
    fn bytes_parse(input: &'static [u8], expected: Bytes) {
        let bytes = Bytes::from_static(input);
        assert_eq!(from_bytes::<Bytes>(bytes).unwrap(), expected);
    }

    #[test_case(&[0xCC, 0x00], Vec::new(); "empty bytes")]
    #[test_case(&[0xCC, 0x04, 0x68, 0x65, 0x6C, 0x6C], Vec::from(b"hell".as_slice()); "hell")]
    #[test_case(&[0xCD, 0x00, 0x04, 0x6F, 0x2C, 0x20, 0x72], Vec::from(b"o, r".as_slice()); "o, r")]
    #[test_case(&[0xCE, 0x00, 0x00, 0x00, 0x04, 0x75, 0x73, 0x74, 0x21], Vec::from(b"ust!".as_slice()); "ust!")]
    fn bytes_vec(input: &'static [u8], expected: Vec<u8>) {
        let bytes = Bytes::from_static(input);
        assert_eq!(from_bytes::<Vec<u8>>(bytes).unwrap(), expected);
    }

    #[test_case(&[0x80], ""; "empty string")]
    #[test_case(&[0x81, 0x41], "A"; "A")]
    #[test_case(&[0xD0, 0x1A, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A], "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; "alphabet")]
    #[test_case(&[0xD0, 0x12, 0x47, 0x72, 0xC3, 0xB6, 0xC3, 0x9F, 0x65, 0x6E, 0x6D, 0x61, 0xC3, 0x9F, 0x73, 0x74, 0xC3, 0xA4, 0x62, 0x65],"Gr√∂√üenma√üst√§be"; "umlauts")]
    #[test_case(&[0xD0, 0x19, 0xF0, 0x9F, 0x91, 0xA9, 0xE2, 0x80, 0x8D, 0xF0, 0x9F, 0x91, 0xA9, 0xE2, 0x80, 0x8D, 0xF0, 0x9F, 0x91, 0xA7, 0xE2, 0x80, 0x8D, 0xF0, 0x9F, 0x91, 0xA7], "üë©‚Äçüë©‚Äçüëß‚Äçüëß"; "emojis")]
    fn string(input: &'static [u8], expected: &str) {
        roundtrip(input, expected.to_owned())
    }

    #[test_case(&[0x81, 0x41], "A"; "tiny")]
    #[test_case(&[0xD0, 0x01, 0x41], "A"; "string_8")]
    #[test_case(&[0xD1, 0x00, 0x01, 0x41], "A"; "string_16")]
    #[test_case(&[0xD2, 0x00, 0x00, 0x00, 0x01, 0x41], "A"; "string_32")]
    fn string_parse(input: &'static [u8], expected: &str) {
        let bytes = Bytes::copy_from_slice(input);
        assert_eq!(from_bytes::<String>(bytes).unwrap(), expected);
    }

    #[test_case(&[0x90], Vec::new(); "empty list")]
    #[test_case(&[0x93, 0x01, 0x02, 0x03], vec![1, 2, 3]; "list_2")]
    #[test_case(&[0xD4, 0x28, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28], (1..=40).collect(); "list_3")]
    fn list(input: &'static [u8], expected: Vec<i64>) {
        roundtrip(input, expected)
    }

    #[test_case(&[0xA0], BTreeMap::new(); "empty")]
    #[test_case(&[0xA1, 0x83, 0x6F, 0x6E, 0x65, 0x2A], [("one".to_owned(), 42)].into_iter().collect(); "tiny")]
    #[test_case(&[0xD8, 0x1A, 0x81, 0x41, 0x01, 0x81, 0x42, 0x02, 0x81, 0x43, 0x03, 0x81, 0x44, 0x04, 0x81, 0x45, 0x05, 0x81, 0x46, 0x06, 0x81, 0x47, 0x07, 0x81, 0x48, 0x08, 0x81, 0x49, 0x09, 0x81, 0x4A, 0x0A, 0x81, 0x4B, 0x0B, 0x81, 0x4C, 0x0C, 0x81, 0x4D, 0x0D, 0x81, 0x4E, 0x0E, 0x81, 0x4F, 0x0F, 0x81, 0x50, 0x10, 0x81, 0x51, 0x11, 0x81, 0x52, 0x12, 0x81, 0x53, 0x13, 0x81, 0x54, 0x14, 0x81, 0x55, 0x15, 0x81, 0x56, 0x16, 0x81, 0x57, 0x17, 0x81, 0x58, 0x18, 0x81, 0x59, 0x19, 0x81, 0x5A, 0x1A], ('A'..='Z').map(|c| (c.to_string(), ((c as u32) - ('@' as u32)) as i64)).collect(); "map_8")]
    fn dictionary(input: &'static [u8], expected: BTreeMap<String, i64>) {
        roundtrip(input, expected)
    }

    #[test_case(&[0xA0], Vec::new(); "empty")]
    #[test_case(&[0xA1, 0x83, 0x6F, 0x6E, 0x65, 0x2A], [("one".to_owned(), 42)].into_iter().collect(); "tiny")]
    #[test_case(&[0xD8, 0x1A, 0x81, 0x41, 0x01, 0x81, 0x42, 0x02, 0x81, 0x43, 0x03, 0x81, 0x44, 0x04, 0x81, 0x45, 0x05, 0x81, 0x46, 0x06, 0x81, 0x47, 0x07, 0x81, 0x48, 0x08, 0x81, 0x49, 0x09, 0x81, 0x4A, 0x0A, 0x81, 0x4B, 0x0B, 0x81, 0x4C, 0x0C, 0x81, 0x4D, 0x0D, 0x81, 0x4E, 0x0E, 0x81, 0x4F, 0x0F, 0x81, 0x50, 0x10, 0x81, 0x51, 0x11, 0x81, 0x52, 0x12, 0x81, 0x53, 0x13, 0x81, 0x54, 0x14, 0x81, 0x55, 0x15, 0x81, 0x56, 0x16, 0x81, 0x57, 0x17, 0x81, 0x58, 0x18, 0x81, 0x59, 0x19, 0x81, 0x5A, 0x1A], ('A'..='Z').map(|c| (c.to_string(), ((c as u32) - ('@' as u32)) as i64)).collect(); "map_8")]
    fn dictionary_vec(input: &'static [u8], expected: Vec<(String, i64)>) {
        let bytes = Bytes::copy_from_slice(input);
        assert_eq!(from_bytes::<Vec<(String, i64)>>(bytes).unwrap(), expected);
    }

    #[test]
    fn dictionary_duplicates() {
        let bytes = Bytes::from_static(&[
            0xA3, 0x85, 0x6B, 0x65, 0x79, 0x5F, 0x31, 0x01, 0x85, 0x6B, 0x65, 0x79, 0x5F, 0x32,
            0x02, 0x85, 0x6B, 0x65, 0x79, 0x5F, 0x31, 0x03,
        ]);

        let expected = [("key_1".to_owned(), 3), ("key_2".to_owned(), 2)]
            .into_iter()
            .collect();

        assert_eq!(
            from_bytes::<BTreeMap<String, i64>>(bytes.clone()).unwrap(),
            expected
        );

        let expected = vec![
            ("key_1".to_owned(), 1),
            ("key_2".to_owned(), 2),
            ("key_1".to_owned(), 3),
        ];

        assert_eq!(from_bytes::<Vec<(String, i64)>>(bytes).unwrap(), expected);
    }

    #[derive(Clone, Debug, PartialEq, Eq, Deserialize, Serialize)]
    enum Structure {
        Unit,
        Int(i64),
        Pair(bool, String),
        List(Vec<i64>),
    }

    #[test_case(&[0xB0, 0x00], Structure::Unit; "unit")]
    #[test_case(&[0xB1, 0x01, 0x2A], Structure::Int(42); "int")]
    #[test_case(&[0xB2, 0x02, 0xC2, 0x81, 0x42], Structure::Pair(false, "B".to_string()); "pair")]
    #[test_case(&[0xB1, 0x03, 0x91, 0x2A], Structure::List(vec![42]); "list")]
    fn structure(input: &'static [u8], expected: Structure) {
        roundtrip(input, expected)
    }

    fn roundtrip<T: DeserializeOwned + Serialize + PartialEq + Debug>(input: &[u8], expected: T) {
        let bytes = Bytes::copy_from_slice(input);
        assert_eq!(from_bytes::<T>(bytes).unwrap(), expected);

        let actual = to_bytes(&expected).unwrap();
        let expected = Bytes::copy_from_slice(input);
        assert_eq!(actual, expected);
    }
}
